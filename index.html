<!DOCTYPE html>
<html lang="he">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Maze Touch Game</title>
<style>
    body {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background: #f0f0f0;
        user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
    }
    canvas {
        border: 2px solid #333;
        touch-action: none;           /* מבטל גלילה ברירת-מחדל במגע */
    }
</style>
</head>
<body>
<div id="score" style="position:absolute;top:10px;left:10px;font-weight:bold"></div>
<canvas id="maze" width="420" height="420"></canvas>

<script>
const canvas   = document.getElementById("maze");
const ctx      = canvas.getContext("2d");

// ---------- יצירת מבוך אקראי ----------
function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

function generateMaze(w, h) {
    const grid = Array.from({ length: h }, () => Array(w).fill("#"));
    function carve(x, y) {
        for (const [dx, dy] of shuffle([[1,0], [-1,0], [0,1], [0,-1]])) {
            const nx = x + dx * 2, ny = y + dy * 2;
            if (ny > 0 && ny < h-1 && nx > 0 && nx < w-1 && grid[ny][nx] === "#") {
                grid[ny-dy][nx-dx] = " ";
                grid[ny][nx] = " ";
                carve(nx, ny);
            }
        }
    }
    grid[1][1] = " ";
    carve(1,1);
    return grid.map(r => r.join(""));
}

const MAZE_W = 21, MAZE_H = 21;
let maze = generateMaze(MAZE_W, MAZE_H);
const cellSize = 20;
canvas.width  = MAZE_W * cellSize;
canvas.height = MAZE_H * cellSize;

let player = { x: 1, y: 1 };        // תא ההתחלה
const goal = {  x: MAZE_W - 2, y: MAZE_H - 2 }; // תא המטרה בקצה

// אויבים שרודפים אחרי השחקן
let enemies = [
    { x: MAZE_W - 2, y: 1 },
    { x: 1, y: MAZE_H - 2 }
];

let score = 0;
let gameOver = false;

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let y = 0; y < maze.length; y++) {
        for (let x = 0; x < maze[y].length; x++) {
            if (maze[y][x] === "#") {
                ctx.fillStyle = "#444";
                ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
        }
    }

    // יעד
    ctx.fillStyle = "gold";
    ctx.fillRect(goal.x * cellSize + 6, goal.y * cellSize + 6, cellSize - 12, cellSize - 12);

    // אויבים
    ctx.fillStyle = "blue";
    for (const e of enemies) {
        ctx.beginPath();
        ctx.arc(e.x * cellSize + cellSize / 2, e.y * cellSize + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
        ctx.fill();
    }

    // שחקן
    ctx.fillStyle = "crimson";
    ctx.beginPath();
    ctx.arc(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
    ctx.fill();

    document.getElementById('score').textContent = `ציון: ${score}`;
}

function canMove(nx, ny) {
    return ny >= 0 && ny < maze.length &&
           nx >= 0 && nx < maze[ny].length &&
           maze[ny][nx] === " ";
}

function move(dx, dy) {
    const nx = player.x + dx;
    const ny = player.y + dy;
    if (canMove(nx, ny)) {
        player = { x: nx, y: ny };
        score++;
        if (player.x === goal.x && player.y === goal.y) {
            gameOver = true;
            setTimeout(() => alert("ניצחת!"), 50);
        }
    }
    requestAnimationFrame(draw);
}

function moveEnemies() {
    if (gameOver) return;
    for (const e of enemies) {
        const options = [];
        let bestDist = Infinity;
        for (const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
            const nx = e.x + dx, ny = e.y + dy;
            if (canMove(nx, ny)) {
                const dist = Math.abs(nx - player.x) + Math.abs(ny - player.y);
                if (dist < bestDist) {
                    options.length = 0; bestDist = dist;
                }
                if (dist === bestDist) options.push({x:nx,y:ny});
            }
        }
        if (options.length) {
            const choice = options[Math.floor(Math.random()*options.length)];
            e.x = choice.x; e.y = choice.y;
        }
        if (e.x === player.x && e.y === player.y) {
            gameOver = true;
            setTimeout(() => alert("נתפסת!"), 50);
        }
    }
    requestAnimationFrame(draw);
}

// ----- שליטה במגע -----
let touchStartX = null, touchStartY = null;

canvas.addEventListener("touchstart", e => {
    e.preventDefault();
    const t = e.touches[0];
    touchStartX = t.clientX;
    touchStartY = t.clientY;
}, { passive: false });

canvas.addEventListener("touchend", e => {
    e.preventDefault();
    if (touchStartX === null || touchStartY === null) return;
    const t  = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    const absX = Math.abs(dx);
    const absY = Math.abs(dy);
    const threshold = 30;           // מרחק מינימלי לזיהוי החלקה

    if (Math.max(absX, absY) < threshold) {
        touchStartX = touchStartY = null;
        return;
    }
    if (absX > absY) {
        move(dx > 0 ? 1 : -1, 0);   // החלקה אופקית
    } else {
        move(0, dy > 0 ? 1 : -1);   // החלקה אנכית
    }
    touchStartX = touchStartY = null;
}, { passive: false });

// תמיכה במקלדת (בדסקטופ)
document.addEventListener("keydown", e => {
    switch (e.key) {
        case "ArrowUp":    move(0, -1); break;
        case "ArrowDown":  move(0,  1); break;
        case "ArrowLeft":  move(-1, 0); break;
        case "ArrowRight": move(1,  0); break;
    }
});
setInterval(moveEnemies, 500);
requestAnimationFrame(draw);
</script>
</body>
</html>
