<!DOCTYPE html>
<html lang="he">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Maze Touch Game</title>
<style>
    body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background: #f0f0f0;
        user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
    }
    canvas {
        border: 2px solid #333;
        touch-action: none;           /* מבטל גלילה ברירת-מחדל במגע */
    }
</style>
</head>
<body>
<canvas id="maze"></canvas>

<script>
const canvas   = document.getElementById("maze");
const ctx      = canvas.getContext("2d");
const cellSize = 20;                // גודל תא קטן יותר למבוכים גדולים

function generateMaze(width, height) {
    if (width % 2 === 0)  width++;   // חייבים ממדים אי‑זוגיים
    if (height % 2 === 0) height++;

    const maze = Array.from({ length: height }, () => Array(width).fill("#"));
    const stack = [{ x: 1, y: 1 }];
    const visited = Array.from({ length: height }, () => Array(width).fill(false));
    visited[1][1] = true;
    maze[1][1] = " ";

    while (stack.length) {
        const current = stack[stack.length - 1];
        const dirs = [
            { x: 2, y: 0 },
            { x: -2, y: 0 },
            { x: 0, y: 2 },
            { x: 0, y: -2 }
        ];
        for (let i = dirs.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
        }

        let moved = false;
        for (const d of dirs) {
            const nx = current.x + d.x;
            const ny = current.y + d.y;
            if (ny > 0 && ny < height - 1 && nx > 0 && nx < width - 1 && !visited[ny][nx]) {
                visited[ny][nx] = true;
                maze[current.y + d.y / 2][current.x + d.x / 2] = " ";
                maze[ny][nx] = " ";
                stack.push({ x: nx, y: ny });
                moved = true;
                break;
            }
        }
        if (!moved) stack.pop();
    }

    return maze.map(row => row.join(""));
}

const maze = generateMaze(21, 21);
canvas.width  = maze[0].length * cellSize;
canvas.height = maze.length * cellSize;

let player = { x: 1, y: 1 };        // תא ההתחלה
const enemy = { x: maze[0].length - 2, y: maze.length - 2 }; // מיקום אויב התחלתי
let foods = [];                     // מאכלים לאיסוף

for (let y = 0; y < maze.length; y++) {
    for (let x = 0; x < maze[y].length; x++) {
        if (maze[y][x] === " " && !(x === player.x && y === player.y) && !(x === enemy.x && y === enemy.y)) {
            foods.push({ x, y });
        }
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // ציור קירות
    for (let y = 0; y < maze.length; y++) {
        for (let x = 0; x < maze[y].length; x++) {
            if (maze[y][x] === "#") {
                ctx.fillStyle = "#444";
                ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
        }
    }
    // ציור מאכלים
    ctx.fillStyle = "gold";
    for (const f of foods) {
        ctx.beginPath();
        ctx.arc(f.x * cellSize + cellSize / 2,
                f.y * cellSize + cellSize / 2,
                cellSize / 6, 0, Math.PI * 2);
        ctx.fill();
    }

    // ציור שחקן
    ctx.fillStyle = "blue";
    ctx.beginPath();
    ctx.arc(player.x * cellSize + cellSize / 2,
            player.y * cellSize + cellSize / 2,
            cellSize / 3, 0, Math.PI * 2);
    ctx.fill();

    // ציור אויב
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(enemy.x * cellSize + cellSize / 2,
            enemy.y * cellSize + cellSize / 2,
            cellSize / 3, 0, Math.PI * 2);
    ctx.fill();
}

function canMove(nx, ny) {
    return ny >= 0 && ny < maze.length &&
           nx >= 0 && nx < maze[ny].length &&
           maze[ny][nx] === " ";
}

function move(dx, dy) {
    const nx = player.x + dx;
    const ny = player.y + dy;
    if (canMove(nx, ny)) {
        player = { x: nx, y: ny };
        // בדיקה אם אכלנו מאכל
        foods = foods.filter(f => !(f.x === player.x && f.y === player.y));
        if (foods.length === 0) {
            setTimeout(() => alert("ניצחת!"), 50);
        }
    }
    enemyMove();
    requestAnimationFrame(draw);
}

function enemyMove() {
    const options = [];
    const dirs = [
        { x: 1, y: 0 },
        { x: -1, y: 0 },
        { x: 0, y: 1 },
        { x: 0, y: -1 }
    ];
    for (const d of dirs) {
        const nx = enemy.x + d.x;
        const ny = enemy.y + d.y;
        if (canMove(nx, ny)) {
            options.push({ x: nx, y: ny });
        }
    }
    if (options.length === 0) return;
    options.sort((a, b) =>
        Math.abs(a.x - player.x) + Math.abs(a.y - player.y) -
        (Math.abs(b.x - player.x) + Math.abs(b.y - player.y))
    );
    enemy.x = options[0].x;
    enemy.y = options[0].y;
    if (enemy.x === player.x && enemy.y === player.y) {
        setTimeout(() => alert("נכשלת"), 50);
    }
}

// ----- שליטה במגע -----
let touchStartX = null, touchStartY = null;

canvas.addEventListener("touchstart", e => {
    e.preventDefault();
    const t = e.touches[0];
    touchStartX = t.clientX;
    touchStartY = t.clientY;
}, { passive: false });

canvas.addEventListener("touchend", e => {
    e.preventDefault();
    if (touchStartX === null || touchStartY === null) return;
    const t  = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    const absX = Math.abs(dx);
    const absY = Math.abs(dy);
    const threshold = 30;           // מרחק מינימלי לזיהוי החלקה

    if (Math.max(absX, absY) < threshold) {
        touchStartX = touchStartY = null;
        return;
    }
    if (absX > absY) {
        move(dx > 0 ? 1 : -1, 0);   // החלקה אופקית
    } else {
        move(0, dy > 0 ? 1 : -1);   // החלקה אנכית
    }
    touchStartX = touchStartY = null;
}, { passive: false });

// תמיכה במקלדת (בדסקטופ)
document.addEventListener("keydown", e => {
    switch (e.key) {
        case "ArrowUp":    move(0, -1); break;
        case "ArrowDown":  move(0,  1); break;
        case "ArrowLeft":  move(-1, 0); break;
        case "ArrowRight": move(1,  0); break;
    }
});

requestAnimationFrame(draw);
</script>
</body>
</html>
